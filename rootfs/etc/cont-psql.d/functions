#!/usr/bin/with-contenv bash
# shellcheck shell=bash disable=SC1008
set -e

## Logging
# $1 message
log-init() {
	s6-echo -- "cont-init: info: $1"
}

## Execute command as PG_USER
exec_as_postgres() {
  sudo -HEu postgres "$@"
}

# shellcheck source=env-defaults
source /etc/cont-psql.d/env-defaults

## Set postgresql parameter
# $1 key
# $2 value
# $3 verbosity default:verbose
set_postgresql_param() {
	local key=${1}
	local value=${2}
	local verbosity=${3:-verbose}

	if [[ -n ${value} ]]; then
		local current
		current=$(s6-setuidgid abc sed -n -e "s/^\(${key} = '\)\([^ ']*\)\(.*\)$/\2/p" "${PG_CONF}")

		if [[ "${current}" != "${value}" ]]; then

			if [[ ${verbosity} == verbose ]]; then
				log-init "setting postgresql.conf parameter: ${key} = '${value}'"
			fi

			# shellcheck disable=SC2001
			value="$(echo "${value}" | sed 's|[&]|\\&|g')"
			s6-setuidgid abc sed -i "s|^[#]*[ ]*${key} = .*|${key} = '${value}'|" "${PG_CONF}"
		fi
	fi
}

## Set HBA Parameter
# $1 value to set in hba config
set_hba_param() {
	local value=${1}

	# shellcheck disable=SC2001
	if ! grep -q "$(sed "s| | \\\+|g" <<< "${value}")" "${PG_HBA_CONF}"; then
		echo "${value}" >> "${PG_HBA_CONF}"
	fi
}

## Check if database is ready for connections
is_db_ready() {
	cmd="pg_isready -h localhost -p 5432 -U ${PG_USER} -d postgres -t 1"
	timeout=${PG_READY_CONNECT_TIMEOUT}
	echo -n "  waiting for database to be ready (${PG_READY_CONNECT_TIMEOUT}s timeout)"
	while ! $cmd > /dev/null 2>&1
	do
		timeout=$((timeout - 1))
		if [[ $timeout -eq 0 ]]; then
			echo "  [TIMEOUT]"
			return 1
		fi

		echo -n "."
		sleep 1
	done
	echo "  [CONNECTED]"
}

## Check if database is ready for connections
is_db_ready_socket() {
	cmd="pg_isready -h /run/postgresql -p 5432 -U ${PG_USER} -d postgres -t 1"
	timeout=${PG_READY_CONNECT_TIMEOUT}
	echo -n "  waiting for database to be ready (${PG_READY_CONNECT_TIMEOUT}s timeout)"
	while ! $cmd > /dev/null 2>&1
	do
		timeout=$((timeout - 1))
		if [[ $timeout -eq 0 ]]; then
			echo "  [TIMEOUT]"
			return 1
		fi

		echo -n "."
		sleep 1
	done
	echo "  [CONNECTED]"
}

## Check if master is ready for connections
is_master_ready() {
	cmd="pg_isready -h ${REPLICATION_HOST} -p ${REPLICATION_PORT} -U ${REPLICATION_USER} -d postgres -t 1"
	timeout=${PG_READY_CONNECT_MASTER_TIMEOUT}
	echo -n "  waiting for ${REPLICATION_HOST} to accept connections (${PG_READY_CONNECT_MASTER_TIMEOUT}s timeout)"
	while ! $cmd > /dev/null 2>&1
	do
		timeout=$((timeout - 1))
		if [[ $timeout -eq 0 ]]; then
			echo "  [TIMEOUT]"
			exit 30
		fi

		echo -n "."
		sleep 1
	done
	echo "  [CONNECTED]"
}

## Check if enabled
# $1 parameter to Check
#
# usage: if is_enabled "${VAR}"; then
is_enabled() {
    local BOOL="${1}"

    # shellcheck disable=2086
    if (( BOOL == 1 )) || [ "${BOOL}" == true ] || [ "${BOOL,,}" = "true" ] || [ "${BOOL,,}" = "enable" ] || [ "${BOOL,,}" = "enabled" ] || [ "${BOOL,,}" = "on" ]; then
        return 0
    fi

    return 1
}

is_greatest() {
	#shellcheck disable=SC2124
	local ARGS=$@
	local ELM="$1"

	for ARG in $ARGS; do
		if [ "$ARG" -gt "${ELM}" ]; then
			ELM="${ARG}"
		fi
	done

	echo "${ELM}"
}

is_least() {
	#shellcheck disable=SC2124
	local ARGS=$@
	local ELM="$1"

	for ARG in $ARGS; do
		if [ "$ARG" -lt "${ELM}" ]; then
			ELM="${ARG}"
		fi
	done

	echo "${ELM}"
}

## Set container timezone
# $1 Timezone
container_set_timezone() {
	cp "/usr/share/zoneinfo/${TZ}" /etc/localtime
	log-init "Timezone set to ${TZ}"
}

psql_configure_data_dir() {
	if [ ! -d "${PG_DATA_DIR}" ]; then
		log-init "creating directory::data [${PG_DATA_DIR}]"
		mkdir -p "${PG_DATA_DIR}"
	else
		log-init "directory::data exists [${PG_DATA_DIR}]"
	fi

	if [ -d "${PG_DATA_DIR}" ]; then
		find "${PG_DATA_DIR}" -type f -exec chmod 0600 {} \;
		find "${PG_DATA_DIR}" -type d -exec chmod 0700 {} \;
	fi

	# Set permissions on PG_HOME
	log-init "setting permissions::home"
	chown -R abc:abc "${PG_HOME}"
}

psql_configure_log_dir() {
	if [ ! -d "${PG_LOG_DIR}" ]; then
		log-init "creating directory::log [${PG_LOG_DIR}]"
		mkdir -p "${PG_LOG_DIR}"
	else
		log-init "directory::log exists [${PG_LOG_DIR}]"
	fi

	# Set permissions on PG_LOGDIR
	log-init "setting permissions::log"
	chmod -R 1775 "${PG_LOG_DIR}"
	chown -R abc:abc "${PG_LOG_DIR}"
}

psql_configure_run_dir() {
	if [ ! -d "${PG_RUN_DIR}" ]; then
		log-init "creating directory::run [${PG_RUN_DIR}]"
		mkdir -p "${PG_RUN_DIR}" "${PG_RUN_DIR}/${PG_VERSION}-main.pg_stat_tmp"
	else
		log-init "directory::run exists [${PG_RUN_DIR}]"
	fi

	if [ ! -L /run/postgresql/postgresql ]; then
		ln -s "${PG_RUN_DIR}" /run/postgresql
	fi

	# Set Permissions on PG_RUN_DIR
	log-init "setting permissions::run"
	chmod -R 0755 "${PG_RUN_DIR}"
	chmod g+s "${PG_RUN_DIR}"
	chown -R abc:abc "${PG_RUN_DIR}"
}

psql_configure_certs_dir() {
	if [ ! -d "${PG_CERTS_DIR}" ]; then
		log-init "creating directory::certs [${PG_CERTS_DIR}]"
		mkdir -p "${PG_CERTS_DIR}"
	else
		log-init "directory::certs exists [${PG_CERTS_DIR}]"
	fi

	# set permissions on PG_CERTS_DIR
	chown abc:abc "${PG_CERTS_DIR}"
}

psql_configure_initdb_dir() {
	if [ ! -d "${PG_INIT_DB_DIR}" ]; then
		log-init "creating directory::init.db.d [${PG_INIT_DB_DIR}]"
		mkdir -p "${PG_INIT_DB_DIR}"
	fi

	# Set permissions on PG_INIT_DB_DIR
	log-init "setting permissions::init.db.d"
	chown -R abc:abc "${PG_INIT_DB_DIR}"
}

psql_configure_archive_dir() {
	if [ ! -d "${PG_ARCHIVE_DIR}" ]; then
		log-init "creating directory::archive [${PG_ARCHIVE_DIR}]"
		mkdir -p "${PG_ARCHIVE_DIR}"
	else
		log-init "directory::archive exists [${PG_ARCHIVE_DIR}]"
	fi

	# Set permissions on PG_INIT_DB_DIR
	log-init "setting permissions::archive"
	chown -R abc:abc "${PG_ARCHIVE_DIR}"
}

psql_configure_net_security() {
	log-init "trusting connections from the local network..."
	set_hba_param "host	all				all				samenet					trust"

	# allow remote connections to postgresql database
	set_hba_param "host	all				all				0.0.0.0/0				md5"

	s6-setuidgid abc touch "${PG_DATA_DIR}/net-security"
}

psql_validate_certs() {
	if is_enabled "${PG_SSL}"; then
		log-init "SSL/TLS: Enabled"

		if [ ! -f "${PG_CERTS_DIR}/server.crt" ]; then
			log-init "ERROR: SSL/TLS is enabled certificate not found [${PG_CERTS_DIR}/server.crt]"
			exit 41
		else
			if [ "$(stat -c "%a" "${PG_CERTS_DIR}/server.crt")" != "644" ]; then
				log-init "invalid permissions for ${PG_CERTS_DIR}/server.crt; expect: 644"
				exit 42
			fi
		fi

		if [ ! -f "${PG_CERTS_DIR}/server.key" ]; then
			log-init "ERROR: SSL/TLS is enabled certificate key not found [${PG_CERTS_DIR}/server.key]"
			exit 43
		else
			if [ "$(stat -c "%a" "${PG_CERTS_DIR}/server.key")" != "600" ]; then
				log-init "invalid permissions for ${PG_CERTS_DIR}/server.key; expect: 600"
				exit 44
			fi
		fi
	fi
}

psql_validate_replicate_params() {
	if [[ -z $REPLICATION_HOST ]]; then
		log-init "ERROR: REPLICATION_MODE=${REPLICATION_MODE^^}; required variable REPLICATION_HOST not set"
		exit 18
	fi

	if [[ -z $REPLICATION_USER ]]; then
		log-init "ERROR: REPLICATION_MODE=${REPLICATION_MODE^^}; required variable REPLICATION_USER not set"
		exit 19
	fi

	if [[ -z $REPLICATION_PASS ]]; then
		echo "ERROR: REPLICATION_MODE=${REPLICATION_MODE^^}; required variable REPLICATION_PASS not set"
		exit 20
	fi
}

psql_validate_pgpass() {
	if [ "$PG_PASS" == "postgres" ]; then
		log-init "WARNING: postgres user password still set to default; only use this for test/dev environments"
	fi
}

psql_validate_db_user() {
	if [[ -z ${DB_USER} ]]; then
		log-init "ERROR: required variable DB_USER not set"
		exit 15
	fi
}

psql_validate_db_pass() {
	if [[ -z ${DB_PASS} ]]; then
		log-init "ERROR: required variable DB_PASS not set"
		exit 16
	fi
}

psql_validate_db_name() {
	if [[ -z ${DB_NAME} ]]; then
		log-init "ERROR: required variable DB_NAME not set"
		exit 17
	fi
}

psql_store_version() {
	log-init "storing postgresql version"
	echo "${PG_VERSION_SLUG}" | s6-setuidgid abc tee "${PG_DATA_DIR}/PG_VERSION_FULL" > /dev/null 2>&1
}

psql_determine_migration_required() {
	PG_OLD_VERSION=$(find "${PG_HOME}" -maxdepth 3 -name PG_VERSION_FULL -exec cat {} + 2>/dev/null | grep -o -E '[0-9]{1,2}\.[0-9]{1,2}' | grep -v "${PG_VERSION_SLUG}" | sort -n | head -n1)
	if [[ -n ${PG_OLD_VERSION} ]]; then
		# Migration is required
		# Enable migration

		PG_OLD_VERSION_MAJOR=$(echo "${PG_OLD_VERSION}" | cut -d '.' -f 1)

		log-init "entering migration mode"
		printf "1" > /var/run/s6/container_environment/PG_MIGRATION
		printf "%s" "${PG_OLD_VERSION}" > /var/run/s6/container_environment/PG_OLD_VERSION
		printf "%s" "${PG_OLD_VERSION_MAJOR}" > /var/run/s6/container_environment/PG_OLD_VERSION_MAJOR
	fi
}

psql_is_migration() {
	if is_enabled "${PG_MIGRATION}"; then
		return 0
	fi

	return 1
}

psql_create_old_rootfs() {
	if (( "${PG_VERSION_MAJOR}" < 12 )); then
		PG_ROOTFS="${PG_HOME}/${PG_VERSION_SLUG}/.rootfs"
		if [ ! -d "${PG_ROOTFS}" ]; then
			log-init "saving postgres for future upgrade"
			mkdir -p "${PG_ROOTFS}"/{lib,usr/{bin,lib}}

			cp -raP /lib/* "${PG_ROOTFS}/lib"
			cp -raP /usr/bin/pg_* "${PG_ROOTFS}/usr/bin"
			cp -raP "${PG_COMMAND}" "${PG_ROOTFS}/usr/bin"
			cp -raP /usr/lib/* "${PG_ROOTFS}/usr/lib"

			case "${PG_VERSION_MAJOR}" in
				9)
					mkdir -p "${PG_ROOTFS}/usr/share/postgresql"
					cp -raP /usr/share/postgresql/{timezone,timezonesets} "${PG_ROOTFS}/usr/share/postgresql"
				;;

				10|11)
					mkdir -p "${PG_ROOTFS}/usr/share/postgresql"
					cp -raP /usr/share/postgresql/timezonesets "${PG_ROOTFS}/usr/share/postgresql"
				;;
			esac
		fi
	fi
}

# EOF
