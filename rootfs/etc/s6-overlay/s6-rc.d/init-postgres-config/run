#!/usr/bin/with-contenv bash
# shellcheck shell=bash disable=SC1008
set -e

# Global functions
# shellcheck source=../../../functions
source /etc/functions

# PostgreSQL environment
# shellcheck source=env
source /etc/s6-overlay/s6-rc.d/init-postgres-config/env

# PostgreSQL functions
# shellcheck source=func
source /etc/s6-overlay/s6-rc.d/init-postgres-config/func

# Repmgr environment
# shellcheck source=env
source /etc/s6-overlay/s6-rc.d/init-repmgr-config/env

# Repmgr functions
# shellcheck source=env
source /etc/s6-overlay/s6-rc.d/init-repmgr-config/func

# Configure data directory
if [ ! -d "${PG_DATA_DIR}" ]; then
  log-init "creating directory::data [${PG_DATA_DIR}]"
  mkdir -p "${PG_DATA_DIR}"
else
  log-init "directory::data exists [${PG_DATA_DIR}]"
fi

if [ -d "${PG_DATA_DIR}" ]; then
  find "${PG_DATA_DIR}" -type f -exec chmod 0600 {} \;
  find "${PG_DATA_DIR}" -type d -exec chmod 0700 {} \;
fi

# Set permissions on PG_HOME
log-init "setting permissions::home"
# Fix: ignore /data/*/.rootfs which is needed for database migration
find "${PG_HOME}" -ipath "${PG_HOME}/*/.rootfs" -prune -o -exec lsiown abc:abc {} +
lsiown abc:abc "${PG_HOME}"

# Configure log directory
if [ ! -d "${PG_LOG_DIR}" ]; then
  log-init "creating directory::log [${PG_LOG_DIR}]"
  mkdir -p "${PG_LOG_DIR}"
else
  log-init "directory::log exists [${PG_LOG_DIR}]"
fi

# Set permissions on PG_LOGDIR
log-init "setting permissions::log"
chmod -R 1775 "${PG_LOG_DIR}"
lsiown -R abc:abc "${PG_LOG_DIR}"

# Configure run directory
if [ ! -d "${PG_RUN_DIR}" ]; then
  log-init "creating directory::run [${PG_RUN_DIR}]"
  mkdir -p "${PG_RUN_DIR}" "${PG_RUN_DIR}/${PG_VERSION}-main.pg_stat_tmp"
else
  log-init "directory::run exists [${PG_RUN_DIR}]"
fi

if [ ! -L /run/postgresql/postgresql ]; then
  ln -s "${PG_RUN_DIR}" /run/postgresql
fi

# Set Permissions on PG_RUN_DIR
log-init "setting permissions::run"
chmod -R 0777 "${PG_RUN_DIR}"
chmod g+s "${PG_RUN_DIR}"
lsiown -R abc:abc "${PG_RUN_DIR}"

# Configure certificate directory
if [ ! -d "${PG_CERTS_DIR}" ]; then
  log-init "creating directory::certs [${PG_CERTS_DIR}]"
  mkdir -p "${PG_CERTS_DIR}"
else
  log-init "directory::certs exists [${PG_CERTS_DIR}]"
fi

# set permissions on PG_CERTS_DIR
lsiown abc:abc "${PG_CERTS_DIR}"

# Configure archive directory
if [ ! -d "${PG_ARCHIVE_ROOT}" ]; then
  log-init "creating directory::archive [${PG_ARCHIVE_ROOT}]"
  mkdir -p "${PG_ARCHIVE_ROOT}"
fi

if [ ! -d "${PG_ARCHIVE_DIR}" ]; then
  log-init "creating directory::archive [${PG_ARCHIVE_DIR}]"
  mkdir -p "${PG_ARCHIVE_DIR}"
fi

# Set permissions on PG_INIT_DB_DIR
log-init "setting permissions::archive"
lsiown -R abc:abc "${PG_ARCHIVE_ROOT}"

# Validate certificates
if is_enabled "${PG_SSL}"; then
  log-init "SSL/TLS: Enabled"

  if [ ! -f "${PG_CERTS_DIR}/server.crt" ]; then
    log-init "ERROR: SSL/TLS is enabled certificate not found [${PG_CERTS_DIR}/server.crt]"
    exit 41
  else
    if [ "$(stat -c "%a" "${PG_CERTS_DIR}/server.crt")" != "644" ]; then
      log-init "invalid permissions for ${PG_CERTS_DIR}/server.crt; expect: 644"
      exit 42
    fi
  fi

  if [ ! -f "${PG_CERTS_DIR}/server.key" ]; then
    log-init "ERROR: SSL/TLS is enabled certificate key not found [${PG_CERTS_DIR}/server.key]"
    exit 43
  else
    if [ "$(stat -c "%a" "${PG_CERTS_DIR}/server.key")" != "640" ]; then
      log-init "invalid permissions for ${PG_CERTS_DIR}/server.key; expect: 640"
      exit 44
    fi
  fi
fi

# Validate parameters
# This most be completed before we even start creating a data directory
# because when this container runs a node in a repmgr cluster it can even be the
# case that repmgr will be responsible for initializing postgresql.
# Therefor even while we are in 'init-postgres-config' we still need to check
# if some repmgr parameters are valid
if ! psql_is_initialized; then
  case ${REPLICATION_MODE,,} in
    standby|repmgr-standby)
      if repmgr_enabled; then
        : # TODO: Implement repmgr parameter validation
      else
        psql_validate_replicate_params
      fi
    ;;

    snapshot|backup)
      psql_validate_replicate_params
    ;;

    repmgr-witness)
      # NO-OP
    ;;

    *)
      # Configure initdb directory
      # We are creating this here, because this should only be created on
      # the primary node
      if [ ! -d "${PG_INIT_DB_DIR}" ]; then
        log-init "creating directory::init.db.d [${PG_INIT_DB_DIR}]"
        mkdir -p "${PG_INIT_DB_DIR}"
      fi

      # Set permissions on PG_INIT_DB_DIR
      log-init "setting permissions::init.db.d"
      lsiown -R abc:abc "${PG_INIT_DB_DIR}"

      # Validate DB_USER
      if [[ -z ${DB_USER} ]]; then
        log-init "ERROR: required variable DB_USER not set"
        exit 15
      fi
      
      # Validate DB_PASS
      if [[ -z ${DB_PASS} ]]; then
        log-init "ERROR: required variable DB_PASS not set"
        exit 16
      fi
      
      # Validate DB_NAME
      if [[ -z ${DB_NAME} ]]; then
        log-init "ERROR: required variable DB_NAME not set"
        exit 17
      fi
    ;;
  esac
fi

# Determine PostgreSQL migration
PG_OLD_VERSION=$(find "${PG_HOME}" -maxdepth 3 -name PG_VERSION_FULL -exec cat {} + 2>/dev/null | grep -o -E '[0-9]{1,2}\.[0-9]{1,2}' | grep -v "${PG_VERSION_SLUG}" | sort -r -n | head -n1)
if [[ -n ${PG_OLD_VERSION} ]]; then

  # Before we mark this for migration, we need to check if this data has
  # already been migrated.
  PG_OLD_DATADIR="${PG_HOME}/${PG_OLD_VERSION}"
  if [ ! -f "${PG_OLD_DATADIR}/.migrated" ]; then
    # Migration is required
    # Enable migration
    PG_OLD_VERSION_MAJOR=$(echo "${PG_OLD_VERSION}" | cut -d '.' -f 1)

    log-init "entering migration mode"
    env_set PG_MIGRATION 1
    env_set PG_OLD_VERSION "${PG_OLD_VERSION}"
    env_set PG_OLD_VERSION_MAJOR "${PG_OLD_VERSION_MAJOR}"
  fi
fi
