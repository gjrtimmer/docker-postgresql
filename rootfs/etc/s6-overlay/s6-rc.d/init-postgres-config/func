#!/usr/bin/with-contenv bash
# shellcheck shell=bash disable=SC1008
set -e

# NAME
#   psql_is_initialized
#
# DESCRIPTION
#   Check if postgresql has been initialized by previous container
#
# USAGE
#   if psql_is_initialized; then
#     {INITIALIZED}
#   else
#     {NOT INITIALIZED}
#   fi
#
psql_is_initialized() {
  if [[ -f ${PG_DATA_DIR}/PG_VERSION ]]; then
    return 0
  else
    return 1
  fi
}

# NAME
#		set_postgresql_param
#
# DESCRIPTION
#		Set PostgreSQL parameter
#
# OPTIONS
#		$1		string		Key
#		$2		string		Value
#
# USAGE
#		set_postgresql_param {KEY} {VALUE}
#
# EXAMPLES
#		set_postgresql_param "wal_compression" on
#		set_postgresql_param "logging_collector" "on"
#
set_postgresql_param() {
  local key=${1}
  local value=${2}

  if [ "$(grep -c "${key}" "${PG_CONF}")" -eq 0 ]; then
    echo "${key} = '${value//[&]/\\&}'" >> "${PG_CONF}"
  fi

  if [[ -n ${value} ]]; then
    local current
    current=$(s6-setuidgid abc sed -n -e "s/^\(${key} = '\)\([^ ']*\)\(.*\)$/\2/p" "${PG_CONF}")

    if [[ "${current}" != "${value}" ]]; then
      log-init "setting postgresql.conf parameter: ${key} = '${value}'"
      s6-setuidgid abc sed -i "s|^[#]*[ ]*${key} = .*|${key} = '${value//[&]/\\&}'|" "${PG_CONF}"
    fi
  fi
}

# NAME
#		set_shared_libraries
#
# DESCRIPTION
#		Add extension to the shared_preload_libraries config parameter
#
# OPTIONS
#		$1		string		Name of extension
#
# USAGE
#		set_shared_libraries {EXTENSION}
#
# EXAMPLES
#		set_shared_libraries pg_cron
#		set_shared_libraries repmgr
#
set_shared_libraries() {
  local value=${1}

  if [[ -n ${value} ]]; then
    local current
    current=$(s6-setuidgid abc sed -n -e "s/^\(shared_preload_libraries = '\)\([^ ']*\)\(.*\)$/\2/p" "${PG_CONF}")

    if [ -z "${current}" ]; then
      lib_list=()
    else
      lib_list=("${current//,/}")
    fi

    # shellcheck disable=SC2076
    if [[ ! " ${lib_list[*]} " =~ "${value}" ]]; then
      log-init "setting postgresql.conf parameter: shared_preload_libraries = '${value}'"

      lib_list+=("${value//[&]/\\&}")
      value=$(join_array , "${lib_list[@]}")

      s6-setuidgid abc sed -i "s|^[#]*[ ]*shared_preload_libraries = .*|shared_preload_libraries = '${value}'|" "${PG_CONF}"
    fi
  fi
}

# NAME
#		set_hba_param
#
# DESCRIPTION
#		Set HBA config
#
# OPTIONS
#		$1		string		HBA Config line
#
# USAGE
#		set_hba_param {HBA_CONFIG_LINE}
#
# EXAMPLES
#		set_hba_param "host	all				all				0.0.0.0/0				md5"
#
set_hba_param() {
  local value=${1}

  # shellcheck disable=SC2001
  if ! grep -q "$(sed "s| | \\\+|g" <<< "${value}")" "${PG_HBA_CONF}"; then
    echo "${value}" >> "${PG_HBA_CONF}"
  fi
}

# NAME
#		is_db_ready
#
# DESCRIPTION
#		Check if the database is ready for TCP/IP connections on localhost
#		this function is used to check if the database is ready while in config
#		mode.
#
# OPTIONS
#		$1		bool		Silent mode, supress output. (default: false)
#
# USAGE
#		is_db_ready
#
# EXAMPLES
#		is_db_ready
#		is_db_ready 1
#
is_db_ready() {
  local SILENT=${1:-0}

  cmd="pg_isready -h localhost -p 5432 -U ${PG_USER} -d postgres -t 1"
  timeout=${PG_READY_CONNECT_TIMEOUT}
  if [ "${SILENT}" -eq 0 ]; then
    echo -n "  waiting for database to be ready (${PG_READY_CONNECT_TIMEOUT}s timeout)"
  fi
  while ! $cmd > /dev/null 2>&1
  do
    timeout=$((timeout - 1))
    if [[ $timeout -eq 0 ]]; then
      if [ "${SILENT}" -eq 0 ]; then
        echo "  [TIMEOUT]"
      fi
      return 1
    fi

    if [ "${SILENT}" -eq 0 ]; then
      echo -n "."
    fi
    sleep 1
  done
  if [ "${SILENT}" -eq 0 ]; then
    echo "  [CONNECTED]"
  fi
}

# NAME
#		is_db_ready_socket
#
# DESCRIPTION
#		Check if the database is ready to accept connections on its socket
#
# OPTIONS
#		$1		bool		Silent mode, supress output. (default: false)
#
# USAGE
#		is_db_ready_socket
#
# EXAMPLES
#		is_db_ready_socket
#		is_db_ready_socket 1
#
is_db_ready_socket() {
  local SILENT=${1:-0}

  cmd="pg_isready -h /run/postgresql -p 5432 -U ${PG_USER} -d postgres -t 1"
  timeout=${PG_READY_CONNECT_TIMEOUT}
  if [ "${SILENT}" -eq 0 ]; then
    echo -n "  waiting for database to be ready (${PG_READY_CONNECT_TIMEOUT}s timeout)"
  fi
  while ! $cmd > /dev/null 2>&1
  do
    timeout=$((timeout - 1))
    if [[ $timeout -eq 0 ]]; then
      if [ "${SILENT}" -eq 0 ]; then
        echo "  [TIMEOUT]"
      fi
      return 1
    fi

    if [ "${SILENT}" -eq 0 ]; then
      echo -n "."
    fi
    sleep 1
  done
  if [ "${SILENT}" -eq 0 ]; then
    echo "  [CONNECTED]"
  fi
}

# NAME
#		is_master_ready
#
# DESCRIPTION
# 	Check if the master node is ready for connections
#
# OPTIONS
#		$1		bool		Silent mode, supress output. (default: false)
#
# USAGE
#		is_master_ready
#
# EXAMPLES
#		is_master_ready
#		is_master_ready 1
#
is_master_ready() {
  local SILENT=${1:-0}

  # shellcheck disable=SC2153
  cmd="pg_isready -h ${REPLICATION_HOST} -p ${REPLICATION_PORT} -U ${REPLICATION_USER} -d postgres -t 1"
  timeout=${PG_READY_CONNECT_MASTER_TIMEOUT}
  if [ "${SILENT}" -eq 0 ]; then
    echo -n "  waiting for ${REPLICATION_HOST} to accept connections (${PG_READY_CONNECT_MASTER_TIMEOUT}s timeout)"
  fi
  while ! $cmd > /dev/null 2>&1
  do
    timeout=$((timeout - 1))
    if [[ $timeout -eq 0 ]]; then
      if [ "${SILENT}" -eq 0 ]; then
        echo "  [TIMEOUT]"
      fi
      exit 30
    fi

    if [ "${SILENT}" -eq 0 ]; then
      echo -n "."
    fi
    sleep 1
  done
  if [ "${SILENT}" -eq 0 ]; then
    echo "  [CONNECTED]"
  fi
}

# NAME
#		psql_configure_data_dir
#
# DESCRIPTION
#		Configure the postgresql data directory
#
psql_configure_data_dir() {
  if [ ! -d "${PG_DATA_DIR}" ]; then
    log-init "creating directory::data [${PG_DATA_DIR}]"
    mkdir -p "${PG_DATA_DIR}"
  else
    log-init "directory::data exists [${PG_DATA_DIR}]"
  fi

  if [ -d "${PG_DATA_DIR}" ]; then
    find "${PG_DATA_DIR}" -type f -exec chmod 0600 {} \;
    find "${PG_DATA_DIR}" -type d -exec chmod 0700 {} \;
  fi

  # Set permissions on PG_HOME
  log-init "setting permissions::home"
  # Fix: ignore /data/*/.rootfs which is needed for database migration
  find "${PG_HOME}" -ipath "${PG_HOME}/*/.rootfs" -prune -o -exec chown "${PUID}:${PGID}" {} +
  chown "${PUID}:${PGID}" "${PG_HOME}"
}

# NAME
#		psql_configure_log_dir
#
# DESCRIPTION
#		Configure the log directory
#
psql_configure_log_dir() {
  if [ ! -d "${PG_LOG_DIR}" ]; then
    log-init "creating directory::log [${PG_LOG_DIR}]"
    mkdir -p "${PG_LOG_DIR}"
  else
    log-init "directory::log exists [${PG_LOG_DIR}]"
  fi

  # Set permissions on PG_LOGDIR
  log-init "setting permissions::log"
  chmod -R 1775 "${PG_LOG_DIR}"
  chown -R "${PUID}:${PGID}" "${PG_LOG_DIR}"
}

# NAME
#		psql_configure_run_dir
#
# DESCRIPTION
#		Configure the run directory
#
psql_configure_run_dir() {
  if [ ! -d "${PG_RUN_DIR}" ]; then
    log-init "creating directory::run [${PG_RUN_DIR}]"
    mkdir -p "${PG_RUN_DIR}" "${PG_RUN_DIR}/${PG_VERSION}-main.pg_stat_tmp"
  else
    log-init "directory::run exists [${PG_RUN_DIR}]"
  fi

  if [ ! -L /run/postgresql/postgresql ]; then
    ln -s "${PG_RUN_DIR}" /run/postgresql
  fi

  # Set Permissions on PG_RUN_DIR
  log-init "setting permissions::run"
  chmod -R 0777 "${PG_RUN_DIR}"
  chmod g+s "${PG_RUN_DIR}"
  chown -R "${PUID}:${PGID}" "${PG_RUN_DIR}"
}

# NAME
#		psql_configure_certs_dir
#
# DESCRIPTION
#		Configure TLS/SSL directory
#
psql_configure_certs_dir() {
  if [ ! -d "${PG_CERTS_DIR}" ]; then
    log-init "creating directory::certs [${PG_CERTS_DIR}]"
    mkdir -p "${PG_CERTS_DIR}"
  else
    log-init "directory::certs exists [${PG_CERTS_DIR}]"
  fi

  # set permissions on PG_CERTS_DIR
  chown "${PUID}:${PGID}" "${PG_CERTS_DIR}"
}

# NAME
#		psql_configure_initdb_dir
#
# DESCRIPTION
#		Configure the initdb directory
#
psql_configure_initdb_dir() {
  if [ ! -d "${PG_INIT_DB_DIR}" ]; then
    log-init "creating directory::init.db.d [${PG_INIT_DB_DIR}]"
    mkdir -p "${PG_INIT_DB_DIR}"
  fi

  # Set permissions on PG_INIT_DB_DIR
  log-init "setting permissions::init.db.d"
  chown -R "${PUID}:${PGID}" "${PG_INIT_DB_DIR}"
}

# NAME
#		psql_configure_archive_dir
#
# DESCRIPTION
#		Configure the archive directory
#
psql_configure_archive_dir() {
  if [ ! -d "${PG_ARCHIVE_ROOT}" ]; then
    log-init "creating directory::archive [${PG_ARCHIVE_ROOT}]"
    mkdir -p "${PG_ARCHIVE_ROOT}"
  fi

  if [ ! -d "${PG_ARCHIVE_DIR}" ]; then
    log-init "creating directory::archive [${PG_ARCHIVE_DIR}]"
    mkdir -p "${PG_ARCHIVE_DIR}"
  fi

  # Set permissions on PG_INIT_DB_DIR
  log-init "setting permissions::archive"
  chown -R "${PUID}:${PGID}" "${PG_ARCHIVE_ROOT}"
}

# NAME
#		psql_configure_hba_security
#
# DESCRIPTION
#
psql_configure_hba_security() {
  if [ ! -f "${PG_DATA_DIR}/net-security" ] && [ ! -f "${PG_DATA_DIR}/PG_HBA_SECURITY" ]; then
    log-init "trusting connections from the local network..."
    set_hba_param "host	all				all				samenet					trust"

    # allow remote connections to postgresql database
    set_hba_param "host	all				all				0.0.0.0/0				md5"

    s6-setuidgid abc touch "${PG_DATA_DIR}/PG_HBA_SECURITY"
  fi
}

# NAME
#		psql_validate_certs
#
# DESCRIPTION
#		Validate existence and permissions of configured certificates
#
psql_validate_certs() {
  if is_enabled "${PG_SSL}"; then
    log-init "SSL/TLS: Enabled"

    if [ ! -f "${PG_CERTS_DIR}/server.crt" ]; then
      log-init "ERROR: SSL/TLS is enabled certificate not found [${PG_CERTS_DIR}/server.crt]"
      exit 41
    else
      if [ "$(stat -c "%a" "${PG_CERTS_DIR}/server.crt")" != "644" ]; then
        log-init "invalid permissions for ${PG_CERTS_DIR}/server.crt; expect: 644"
        exit 42
      fi
    fi

    if [ ! -f "${PG_CERTS_DIR}/server.key" ]; then
      log-init "ERROR: SSL/TLS is enabled certificate key not found [${PG_CERTS_DIR}/server.key]"
      exit 43
    else
      if [ "$(stat -c "%a" "${PG_CERTS_DIR}/server.key")" != "640" ]; then
        log-init "invalid permissions for ${PG_CERTS_DIR}/server.key; expect: 640"
        exit 44
      fi
    fi
  fi
}

# NAME
#		psql_validate_replicate_params
#
# DESCRIPTION
#		Validate the replication configuration
#
psql_validate_replicate_params() {
  if [[ -z $REPLICATION_HOST ]]; then
    log-init "ERROR: REPLICATION_MODE=${REPLICATION_MODE^^}; required variable REPLICATION_HOST not set"
    exit 18
  fi

  if [[ -z $REPLICATION_USER ]]; then
    log-init "ERROR: REPLICATION_MODE=${REPLICATION_MODE^^}; required variable REPLICATION_USER not set"
    exit 19
  fi

  if [[ -z $REPLICATION_PASS ]]; then
    echo "ERROR: REPLICATION_MODE=${REPLICATION_MODE^^}; required variable REPLICATION_PASS not set"
    exit 20
  fi
}

# NAME
#		psql_validate_pgpass
#
# DESCRIPTION
#		Validate postgres password
#
psql_validate_pgpass() {
  if [ "$PG_PASS" == "postgres" ]; then
    log-init "WARNING: postgres user password still set to default; only use this for test/dev environments"
  fi
}

# NAME
#		psql_validate_db_user
#
# DESCRIPTION
#		Validate database user
#
psql_validate_db_user() {
  if [[ -z ${DB_USER} ]]; then
    log-init "ERROR: required variable DB_USER not set"
    exit 15
  fi
}

# NAME
#		psql_validate_db_pass
#
# DESCRIPTION
#		Validate database password
#
psql_validate_db_pass() {
  if [[ -z ${DB_PASS} ]]; then
    log-init "ERROR: required variable DB_PASS not set"
    exit 16
  fi
}

# NAME
#		psql_validate_db_name
#
# DESCRIPTION
#		Validate database name
#
psql_validate_db_name() {
  if [[ -z ${DB_NAME} ]]; then
    log-init "ERROR: required variable DB_NAME not set"
    exit 17
  fi
}

# NAME
#		psql_store_version
#
# DESCRIPTION
#		Store the PostgreSQL version, this is used for future migrations
#
psql_store_version() {
  log-init "storing postgresql version"
  echo "${PG_VERSION_SLUG}" | s6-setuidgid abc tee "${PG_DATA_DIR}/PG_VERSION_FULL" > /dev/null 2>&1
}

# NAME
#		psql_determine_migration_required
#
# DESCRIPTION
#		Determine if a migration is required
#
psql_determine_migration_required() {
  PG_OLD_VERSION=$(find "${PG_HOME}" -maxdepth 3 -name PG_VERSION_FULL -exec cat {} + 2>/dev/null | grep -o -E '[0-9]{1,2}\.[0-9]{1,2}' | grep -v "${PG_VERSION_SLUG}" | sort -r -n | head -n1)
  if [[ -n ${PG_OLD_VERSION} ]]; then

    # Before we mark this for migration, we need to check if this data has
    # already been migrated.
    PG_OLD_DATADIR="${PG_HOME}/${PG_OLD_VERSION}"
    if [ ! -f "${PG_OLD_DATADIR}/.migrated" ]; then
      # Migration is required
      # Enable migration

      PG_OLD_VERSION_MAJOR=$(echo "${PG_OLD_VERSION}" | cut -d '.' -f 1)

      log-init "entering migration mode"
      env_set PG_MIGRATION 1
      env_set PG_OLD_VERSION "${PG_OLD_VERSION}"
      env_set PG_OLD_VERSION_MAJOR "${PG_OLD_VERSION_MAJOR}"
    fi
  fi
}

# NAME
#		psql_is_migration
#
# DESCRIPTION
#		Determine if we are in migration mode. This mode is set on container level
#		with env_set.
#
psql_is_migration() {
  if is_enabled "${PG_MIGRATION}"; then
    return 0
  fi

  return 1
}

# NAME
#   psql_is_migration_success
#
# DESCRIPTION
#   Check if migration went succesful
#
psql_is_migration_success() {
  if is_enabled "${PG_MIGRATION_SUCCESS}"; then
    return 0
  fi

  return 1
}

# NAME
#		psql_create_old_rootfs
#
# DESCRIPTION
#		In order to perform a succesful migration we are required to have access
#		to the previous PostgreSQL version. However when we start a new container
#		over a already existing dataset, we do not have access to this old PostgreSQL
#		to mitigate this issue we are making sure that when we are creating a new
#		dataset we store the correct old rootfs including the required binaries
#		for PostgreSQL into the data directory so we have access to it when
#		we need to perform a migration
#
psql_create_old_rootfs() {
  if (( "${PG_VERSION_MAJOR}" < 12 )); then
    PG_ROOTFS="${PG_HOME}/${PG_VERSION_SLUG}/.rootfs"
    if [ ! -d "${PG_ROOTFS}" ]; then
      log-init "saving postgres for future upgrade"
      mkdir -p "${PG_ROOTFS}"/{lib,usr/{bin,lib}}

      cp -raP /lib/* "${PG_ROOTFS}/lib"
      cp -raP /usr/bin/pg_* "${PG_ROOTFS}/usr/bin"
      cp -raP "${PG_COMMAND}" "${PG_ROOTFS}/usr/bin"
      cp -raP /usr/lib/* "${PG_ROOTFS}/usr/lib"

      case "${PG_VERSION_MAJOR}" in
        9)
          mkdir -p "${PG_ROOTFS}/usr/share/postgresql"
          cp -raP /usr/share/postgresql/{timezone,timezonesets} "${PG_ROOTFS}/usr/share/postgresql"
        ;;

        10|11)
          mkdir -p "${PG_ROOTFS}/usr/share/postgresql"
          cp -raP /usr/share/postgresql/timezonesets "${PG_ROOTFS}/usr/share/postgresql"
        ;;
      esac
    fi
  fi
}

# NAME
#   psql_configure_inetd_service
#
# DESCRIPTION
#   Enabling psql-check inetd service
#
psql_configure_inetd_service() {
  log-init "configure::psql-check"
  if ! grep -q psql-check /etc/services; then
    echo 'psql-check	9001/tcp			# psql-check' >> /etc/services
  fi
}
